import json
import os
import tempfile
from datetime import datetime
import markdown
from weasyprint import HTML, CSS
from analysis_tasks import get_job_result

def generate_markdown_report(job_id):
    """Generate markdown report for a job"""
    result = get_job_result(job_id)
    if not result:
        return None
    
    md_content = f"""# Video QA Analysis Report

**Job ID:** {job_id}  
**Filename:** {result['filename']}  
**Analysis Date:** {result['analysis_timestamp']}  
**Status:** {result['summary']['status']}

## Executive Summary

{_format_summary_bullets(result['summary']['points'])}

**Total Issues Found:** {result['summary']['total_issues']}  
**High Severity Issues:** {result['summary']['high_severity_issues']}

## Technical Specifications

| Metric | Value |
|--------|-------|
| Duration | {result['metadata'].get('duration', 'N/A')} seconds ({result['metrics'].get('duration_formatted', 'N/A')}) |
| Resolution | {result['metrics'].get('resolution', 'N/A')} |
| Frame Rate | {result['metadata'].get('fps', 'N/A')} FPS |
| File Size | {result['metrics'].get('file_size_mb', 'N/A')} MB |
| Video Codec | {result['metadata'].get('video_codec', 'N/A')} |
| Audio Codec | {result['metadata'].get('audio_codec', 'N/A')} |
| Sample Rate | {result['metadata'].get('sample_rate', 'N/A')} Hz |
| Integrated LUFS | {result['metrics'].get('integrated_lufs', 'N/A')} |
| Dynamic Range | {result['metrics'].get('dynamic_range_db', 'N/A')} dB |

## Audio Issues

{_format_issues_table(result['audio_issues'])}

## Video Issues

{_format_issues_table(result['video_issues'])}

## Recommendations

{_generate_recommendations(result['audio_issues'], result['video_issues'], result['metrics'])}

---

*Report generated by AI Video QA System*
"""
    
    return md_content

def generate_pdf_report(job_id):
    """Generate PDF report for a job"""
    md_content = generate_markdown_report(job_id)
    if not md_content:
        return None
    
    # Convert markdown to HTML
    html_content = markdown.markdown(md_content, extensions=['tables'])
    
    # Add CSS styling
    css_content = """
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
    }
    h1, h2, h3 {
        color: #2c3e50;
        border-bottom: 2px solid #3498db;
        padding-bottom: 10px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 12px;
        text-align: left;
    }
    th {
        background-color: #f8f9fa;
        font-weight: bold;
    }
    .severity-high { color: #e74c3c; font-weight: bold; }
    .severity-medium { color: #f39c12; font-weight: bold; }
    .severity-low { color: #27ae60; }
    """
    
    # Create temporary PDF file
    temp_dir = tempfile.gettempdir()
    pdf_path = os.path.join(temp_dir, f"{job_id}_report.pdf")
    
    # Generate PDF
    HTML(string=html_content).write_pdf(
        pdf_path,
        stylesheets=[CSS(string=css_content)]
    )
    
    return pdf_path

def _format_summary_bullets(points):
    """Format summary points as markdown bullets"""
    return '\n'.join(f"- {point}" for point in points)

def _format_issues_table(issues):
    """Format issues as a markdown table"""
    if not issues:
        return "*No issues detected.*\n"
    
    table = "| Timestamp | Type | Severity | Duration | Description | Suggested Fix |\n"
    table += "|-----------|------|----------|----------|-------------|---------------|\n"
    
    for issue in issues:
        duration_str = f"{issue['duration']:.3f}s" if issue['duration'] > 0 else "N/A"
        table += f"| {issue['timestamp']} | {issue['type'].replace('_', ' ').title()} | {issue['severity'].title()} | {duration_str} | {issue['description']} | {issue['suggested_fix']} |\n"
    
    return table

def _generate_recommendations(audio_issues, video_issues, metrics):
    """Generate recommendations based on analysis"""
    recommendations = []
    
    # Audio recommendations
    audio_types = set(issue['type'] for issue in audio_issues)
    
    if 'clipping' in audio_types:
        recommendations.append("**Audio Clipping:** Reduce input gain during recording or apply limiting in post-production.")
    
    if 'low_loudness' in audio_types:
        recommendations.append("**Low Audio Levels:** Apply normalization or increase gain to meet broadcast standards (-23 LUFS for broadcast, -16 LUFS for streaming).")
    
    if 'high_loudness' in audio_types:
        recommendations.append("**High Audio Levels:** Reduce overall levels to prevent distortion and comply with platform requirements.")
    
    if 'silence' in audio_types:
        recommendations.append("**Silence Issues:** Review silent sections to ensure they are intentional. Consider adding background audio or removing gaps.")
    
    if 'voice_glitch' in audio_types:
        recommendations.append("**Voice Glitches:** Check source audio for artifacts. Consider re-recording affected sections or applying audio repair tools.")
    
    # Video recommendations
    video_types = set(issue['type'] for issue in video_issues)
    
    if 'black_frame' in video_types:
        recommendations.append("**Black Frames:** Verify if black frames are intentional. Check encoding settings and source material integrity.")
    
    if 'frozen_frame' in video_types:
        recommendations.append("**Frozen Frames:** Review encoding parameters, especially frame rate and compression settings. Check source material for issues.")
    
    # Technical recommendations based on metrics
    lufs = metrics.get('integrated_lufs')
    if lufs != 'N/A' and isinstance(lufs, (int, float)):
        if lufs < -28:
            recommendations.append("**Technical:** Audio levels are below recommended minimum. Consider amplification or normalization.")
        elif lufs > -12:
            recommendations.append("**Technical:** Audio levels exceed recommended maximum. Apply compression or limiting.")
    
    # General recommendations
    if not recommendations:
        recommendations.append("**Overall:** Video meets basic quality standards. Consider periodic quality checks for consistency.")
    else:
        recommendations.append("**General:** Address high-severity issues first, then medium-severity issues for optimal quality.")
    
    return '\n'.join(f"- {rec}" for rec in recommendations)
